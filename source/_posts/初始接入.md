---
title: 初始接入
date: 2024-09-13 21:22:01
categories:
    - 5G
---
# SSB

SSB主要用来做初始接入，下图展示了SSB的频域位置

![20240913231002](https://raw.githubusercontent.com/gjhOVO/PicGo/main/PicGo/images20240913231002.png#pic_center)

SSB有以下几种pattern

![20240913231523](https://raw.githubusercontent.com/gjhOVO/PicGo/main/PicGo/images20240913231523.png)

SSB由4种信号组成，PSS/SSS/DMRS/PBCH

## PSS主同步信号：

![20240913231632](https://raw.githubusercontent.com/gjhOVO/PicGo/main/PicGo/images20240913231632.png)

## SSS辅同步信号：

![20240913231745](https://raw.githubusercontent.com/gjhOVO/PicGo/main/PicGo/images20240913231745.png)

得到了这两个信号就可以得到物理小区PCI：

![20240913231821](https://raw.githubusercontent.com/gjhOVO/PicGo/main/PicGo/images20240913231821.png)

小区初始接入搜索实际上是按照GSCN进行遍历搜索，寻找PSS和SSS。得到了这两个信号就可以开始解调PBCH，解调PBCH需要先得到参考信号PBCH--DMRS

DMRS在时频域频域上的位置：

![20240913231924](https://raw.githubusercontent.com/gjhOVO/PicGo/main/PicGo/images20240913231924.png)

解调了PBCH的DMRS以后就可以解调PBCH中的payload，也就是MIB信息：

![20240916210526](https://raw.githubusercontent.com/gjhOVO/PicGo/main/PicGo/images20240916210526.png)

同时 `subCarrierSpaceingCommon`在FR1中可以表示CRB的SCS：15/30k，而SSB到CRB偏移的kssb计算值参照以15k为单位，在FR2中，偏移SCS单位和CRB的SCS相同都为60/120k
可以看到kssb用了5个bit来表示，但是实际上kssb取值范围是0-23，因此还多出来了几个值，这几个值是用来加快SSB搜索的。有一些SSB是用来接入小区的，叫做Cell Defined SSB（CD-SSB），还有一些SSB是用于测量，称为Not Cell Defined SSB（NCD-SSB），当初始接入时搜索到NCD-SSB，实际上是在拖累接入速度，因此用kssb=[24,31]来表示这些是异常SSB，不是用来初始接入的，并且根据异常kssb的值，可以更快找到下一个SSB所在位置 ：
结合下表，根据kssb和pdcch-ConfigSIB1的找到GSCN_Offset再加上当前的GSCN号，就是下一个搜索的GSCN号，这样加快了初始接入的速度。而FR1的kssb=30跟FR2的kssb=14就是说这个GSCN附近都没有SSB可以搜索，具体范围是[GSCN-GSCN_OffsetStart,GSCN+GSCN_OffsetEnd]，OffsetStart是pdcch-ConfigSIB1的高4位，OffsetEnd是低四位

![20240916210821](https://raw.githubusercontent.com/gjhOVO/PicGo/main/PicGo/images20240916210821.png)

# Coreset0

仅仅接收到MIB信息还不足以完成初始接入，还需要一些其它的系统信息——RMSI，这些信息会在PDSCH上发送，而PDSCH消息的发送需要DCI信息来指示，DCI信息在PDCCH上发送，因此需要在PDCCH上进行盲检获得DCI信息，从而完成RMSI信息的接收。这个过程需要Coreset0（Common Search Space）：

![20240916210904](https://raw.githubusercontent.com/gjhOVO/PicGo/main/PicGo/images20240916210904.png)

Coreset0是通过SSB获得的，这些信息就放在pdcch-ConfigSIB1中：

![20240916210937](https://raw.githubusercontent.com/gjhOVO/PicGo/main/PicGo/images20240916210937.png)

高4位指明了Coreset0的频域资源，低4位指明了时域资源找的过程如下：
1. 根据kssb得到SSB所在RB的起始位置（SSB是RE对齐）
2. 根据pdcch-ConfigSIB1中的高4位进行查表，如上图所示，其中PDCCH的SCS由MIB的subCarrierSpacingCommon指示，而SSB的SCS则是协议已经规定了哪个频段可以用的SSB的Case和SCS
3. 查看和SSB的SCS以及PDCCH的SCS对应的表，根据高四位组成的index来获得Coreset0信息，下图表明pdcch-ConfigSIB1的值为0，得到了Coreset0的RB数，Symbol数以及相对SSB的偏移，因此也就确定了频域位置。

![20240916211004](https://raw.githubusercontent.com/gjhOVO/PicGo/main/PicGo/images20240916211004.png)

4. 根据低四位获得时域监听位置（还是以上图为例）

![20240916211014](https://raw.githubusercontent.com/gjhOVO/PicGo/main/PicGo/images20240916211014.png)

   
 实际上Coreset在时域上的位置是有Coreset的参数来确定的，这个参数是在RRC建立后下发：
    SearchSpace -> monitoringSymbolsWithinSlot : 监听coreset的起始符号
    ControlResourceSet -> duration : coreset的符号数

对于Coreset0而言，还没有完成初始接入，第一个参数实际上就是表中的First Symbol Index和 N_"symb" ^"CORESET"
5. 得到了时域位置，拿到了O和M两个参数：

![20240916211211](https://raw.githubusercontent.com/gjhOVO/PicGo/main/PicGo/images20240916211211.png)

O的意思是相对于偶数帧起始位置的偏移(ms)，1ms包含2^μ 个slot，实际上指示了第一个SSB的位置：

![20240916211227](https://raw.githubusercontent.com/gjhOVO/PicGo/main/PicGo/images20240916211227.png)

M就可以理解为一个SSB对应多少个slot偏移，结合表中一个slot有几个搜索空间来看记为N,N=1,coreset用1个符号，First Symbol Index=0：

![20240916211245](https://raw.githubusercontent.com/gjhOVO/PicGo/main/PicGo/images20240916211245.png)

N=2，M=1/2，coreset用1个符号，SSB index偶数First Symbol为0，SSB index为奇数，First Symbol为Coreset SymbolNum：两个SSB共用同一个时隙就叫M=1/2，下图中同一个时隙内的蓝色和粉色部分，就是相邻的两个SSB的coreset起始符号，因此每过两个SSB index，监听的起始slot+1

![20240916211253](https://raw.githubusercontent.com/gjhOVO/PicGo/main/PicGo/images20240916211253.png)

# RMSI

## 频域

有了coreset0和searchspace0的视频资源以后就可以利用RNTI搜索RMSI——SIB1。根据DCI format 1_0指示在PDSCH接收RMSI。其中RNTI是DCI的加扰方式，可以理解为DCI的一种标识号。这里的RNTI是SI-RNTI，value为0xFFFF。其中coreset0的调度方式是CCE，Type 0 CSS按照协议规定有几个聚合等级：

![20240922164909](https://raw.githubusercontent.com/gjhOVO/PicGo/main/PicGo/images20240922164909.png)

![20240922165528](https://raw.githubusercontent.com/gjhOVO/PicGo/main/PicGo/images20240922165528.png)

DCI format 1_0结构如下：

![20240922192902](https://raw.githubusercontent.com/gjhOVO/PicGo/main/PicGo/images20240922192902.png)

其中DCI format 1_0只能用type 1调度（Type 0是RBG粒度，Type 1是RB粒度）：

`Two downlink resource allocation schemes, type 0 and type 1, are supported. The UE shall assume that when the 
scheduling grant is received with DCI format 1_0, 4_0 or 4_1 then downlink resource allocation type 1 is used.`

Type 0的RBG大小由协议：

![20240922195726](https://raw.githubusercontent.com/gjhOVO/PicGo/main/PicGo/images20240922195726.png)

例如BWP size=24RB，configuration=1，RBG size=2，那么BWP内有12个RBG，分配资源的位图bit就有12位。

Type 1用起始位置RB(S)和RB数(L)来描述(下标从0开始)，通过RIV的形式告知UE：

![20240922202314](https://raw.githubusercontent.com/gjhOVO/PicGo/main/PicGo/images20240922202314.png)

如下图所示，假设N=7，如果只用第一个公式算，每一对(L,S)虽然有唯一对应的值，但是最大值42要6bit表示，而采用else后面的公式，则是把0-27都填满，只需要5个bit，节省了一个bit。
**SIB1中本来就会携带Initial BWP信息，此处用的BWP是用coreset0的RB数作为N，带入推算S，L**

![20240922202958](https://raw.githubusercontent.com/gjhOVO/PicGo/main/PicGo/images20240922202958.png)

## 时域

PDSCH支持符号级别调度，gNodeB会给UE发送一张表，然后后续发送index，直接在表里面查找index就行了，但是初始接入阶段，gNodeB甚至还不知道UE的存在，因此存在了几张默认的表给UE使用，根据coreset0的服用pattern来选择。

![20240922205100](https://raw.githubusercontent.com/gjhOVO/PicGo/main/PicGo/images20240922205100.png)

假设是patternA则查表：

![20240922205235](https://raw.githubusercontent.com/gjhOVO/PicGo/main/PicGo/images20240922205235.png)

Row index就是Time Domain resource assignment字段的4bit(0-15对应表格的1-16),K0表示PDSCH相对PDCCH的偏移，K0=0表示同一时隙，K0=1表示PDSCH在PDCCH的下一个时隙，S表示起始符号，L表示符号数量，参考RIV，时域用SLIV表示：

![20240922210049](https://raw.githubusercontent.com/gjhOVO/PicGo/main/PicGo/images20240922210049.png)

![20240922210200](https://raw.githubusercontent.com/gjhOVO/PicGo/main/PicGo/images20240922210200.png)

至于dmrs和mapping type在PDSCH中再进行说明。